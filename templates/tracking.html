<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drone Dispatch System</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f6f8fa;
      margin: 0;
      padding: 0;
    }

    header {
      background: #2d3748;
      color: #fff;
      padding: 1.5rem 0;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .hero {
      max-width: 1200px;
      margin: 2rem auto 0;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.07);
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      padding: 1rem;
      flex-direction: column;
    }

    #map {
      width: 100%;
      height: 400px;
      border-radius: 16px;
    }

    #eta {
      margin-top: 1rem;
      font-size: 1.2rem;
      color: #2563eb;
      font-weight: bold;
    }

    .container {
      max-width: 1200px;
      margin: 2rem auto;
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      padding: 0 1rem;
    }

    .info-box {
      flex: 1 1 350px;
      background: #fff;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.07);
      min-width: 280px;
    }

    h2 {
      color: #2563eb;
    }

    h3 {
      color: #16a34a;
    }
  </style>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>

<body>
  <header>
    <h1>Drone Dispatch System</h1>
  </header>
  <section class="hero">
    <div id="map"></div>
    <div id="batch-token-anchor"></div>
    <div id="drone-status-list"></div>
  </section>
  <style>
    #drone-status-list {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1.5rem;
      justify-content: center;
    }

    .drone-status-box {
      background: #f6f8fa;
      border: 2px solid #2563eb;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(37, 99, 235, 0.08);
      padding: 1rem 1.5rem;
      min-width: 220px;
      max-width: 320px;
      font-family: 'Segoe UI', Arial, sans-serif;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .drone-status-box strong {
      color: #2563eb;
    }

    .drone-eta {
      font-size: 1.1rem;
      color: #16a34a;
      margin-top: 0.5em;
      font-weight: bold;
    }

    #batch-token-form {
      background: #fff;
      border: 2px solid #d90429;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(217, 4, 41, 0.08);
      padding: 1rem 1.5rem;
      margin-top: 1rem;
      min-width: 220px;
      max-width: 320px;
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    #batch-token-form label {
      color: #d90429;
      font-weight: bold;
    }

    #batch-token-form input[type="text"] {
      border: 2px solid #d90429;
      border-radius: 4px;
      padding: 0.4rem 0.7rem;
      font-size: 1rem;
      background: #fffdf6;
      color: #222;
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 0.5em;
    }

    #batch-token-form button {
      background: #d90429;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 1rem;
      padding: 0.5rem 1.2rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    #batch-token-form button:hover {
      background: #2563eb;
    }
  </style>
  </section>
  <main class="container">
    <section class="info-box">
      <h2>Delivery Information</h2>
      <strong>Vaccine :</strong>
      {% if data and data.vaccine_types %}
      {% set counts = {} %}
      {% for v in data.vaccine_types %}
      {% set counts = counts.update({v: counts.get(v, 0) | default(0, true) + 1}) or counts %}
      {% endfor %}
      {% for k, v in counts.items() %}
      {{ k }}: {{ v }}{% if not loop.last %}, {% endif %}
      {% endfor %}
      {% else %}
      ---
      {% endif %}
      <br>
      <strong>Latitude:</strong> {{ data.latitude if data else '---' }}<br>
      <strong>Longitude:</strong> {{ data.longitude if data else '---' }}<br>
      <strong>Distance:</strong> {{ data.distance if data else '---' }} km<br>
      <strong>Access Token:</strong> <span id="serverToken">{{ token if token else '' }}</span>
    </section>

  </main>
</body>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  // ------------------ Setup ------------------
  const homeLat = 30.3529, homeLng = 76.3637;
  const targetLat = parseFloat("{{ data.latitude|default(30.3529) }}");
  const targetLng = parseFloat("{{ data.longitude|default(76.3637) }}");

  const serverToken = document.getElementById("serverToken").innerText.trim() ||
    Math.floor(100000 + Math.random() * 900000).toString(); // fallback token

  const map = L.map('map').setView([homeLat, homeLng], 14);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

  L.marker([homeLat, homeLng]).addTo(map).bindPopup("Home Station").openPopup();
  L.marker([targetLat, targetLng]).addTo(map).bindPopup("Delivery Location");

  // ------------------ No Fly Zones ------------------
  // Define no-fly zones directly as circles: [centerLat, centerLng, radius]
  const noFlyZones = [
    [30.3565, 76.3615, 0.002], // Zone 1
    [30.3495, 76.3565, 0.002], // Zone 2
    [30.3465, 76.3665, 0.002], // Zone 3
    [30.3515, 76.3715, 0.002], // Zone 4
    [30.34325, 76.36125, 0.0015] // Zone 5
  ];

  // Render zones as circles
  noFlyZones.forEach(([lat, lng, r]) => {
    L.circle([lat, lng], {
      radius: r * 111000, // convert approx degrees → meters
      color: "red",
      fillColor: "red",
      fillOpacity: 0.5
    }).addTo(map);
  });


  // ------------------ Check if destination is inside a no-fly zone ------------------
  function isPointInsideNoFlyZones(point, zones) {
    const [lat, lng] = point;
    for (const [cLat, cLng, radius] of zones) {
      const dLat = lat - cLat;
      const dLng = lng - cLng;
      const dist = Math.sqrt(dLat * dLat + dLng * dLng);
      if (dist <= radius) {
        return true; // inside zone
      }
    }
    return false;
  }

  // ------------------ Path Calculation ------------------
  function computeSafePath(start, end, zones) {
    const path = [start];
    let current = start;
    // helper: check if line intersects circle
    function lineIntersectsCircle(p1, p2, center, r) {
      const [x1, y1] = [p1[1], p1[0]];
      const [x2, y2] = [p2[1], p2[0]];
      const [cx, cy] = [center[1], center[0]];

      const dx = x2 - x1, dy = y2 - y1;
      const fx = x1 - cx, fy = y1 - cy;

      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = (fx * fx + fy * fy) - r * r;

      let disc = b * b - 4 * a * c;
      if (disc < 0) return false;
      disc = Math.sqrt(disc);
      const t1 = (-b - disc) / (2 * a);
      const t2 = (-b + disc) / (2 * a);

      return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
    }

    while (true) {
      let detourAdded = false;

      for (const zone of zones) {
        const [cLat, cLng, radius] = zone;

        // if current→end intersects this zone
        if (lineIntersectsCircle(current, end, [cLat, cLng], radius)) {
          const [sLat, sLng] = current;

          // base angle from current → circle center
          const baseAngle = Math.atan2(cLat - sLat, cLng - sLng);

          // try two tangent detours
          const tangentCandidates = [];
          [Math.PI / 2, -Math.PI / 2].forEach(offset => {
            const angle = baseAngle + offset;
            tangentCandidates.push([
              cLat + (radius + 0.0005) * Math.sin(angle), // <-- added margin
              cLng + (radius + 0.0005) * Math.cos(angle)  // <-- added margin
            ]);
          });


          // pick first safe tangent candidate
          let safeDetour = null;
          for (const cand of tangentCandidates) {
            let safe = true;
            for (const z of zones) {
              const [czLat, czLng, r] = z;
              if (lineIntersectsCircle(cand, end, [czLat, czLng], r)) {
                safe = false;
                break;
              }
            }
            if (safe) {
              safeDetour = cand;
              break;
            }
          }

          // fallback if none safe: expand outward from circle
          if (!safeDetour) {
            let cand = tangentCandidates[0];
            let tries = 0;
            while (tries < 50) {
              cand = [
                cLat + (radius + 0.0005 * (tries + 1)) * Math.sin(baseAngle + Math.PI / 2),
                cLng + (radius + 0.0005 * (tries + 1)) * Math.cos(baseAngle + Math.PI / 2)
              ];
              // check if cand→end is safe...
              let ok = true;
              for (const z of zones) {
                const [czLat, czLng, r] = z;
                if (lineIntersectsCircle(cand, end, [czLat, czLng], r)) {
                  ok = false;
                  break;
                }
              }
              if (ok) { safeDetour = cand; break; }
              tries++;
            }
          }


          path.push(safeDetour);
          current = safeDetour;
          detourAdded = true;
          break; // re-check from new current
        }
      }

      if (!detourAdded) {
        path.push(end);
        break;
      }
    }

    return path;
  }


  // ------------------ Draw Path ------------------
  let path = [];  // declare globally

  if (isPointInsideNoFlyZones([targetLat, targetLng], noFlyZones)) {
    alert("❌ Cannot deliver: Destination lies inside a no-fly zone!");
  } else {
    path = computeSafePath([homeLat, homeLng], [targetLat, targetLng], noFlyZones);
    L.polyline(path, { color: 'blue', weight: 4 }).addTo(map);
  }




  // ------------------ Animation Helpers (Multiple Drones) ------------------
  const droneIcon = L.icon({ iconUrl: "static/icons/drone.ico", iconSize: [40, 40], iconAnchor: [20, 20] });
  const distanceMeters = map.distance([homeLat, homeLng], [targetLat, targetLng]);
  const durationMs = (distanceMeters / 1000 / 100) * 3600 * 1000; // speed=100 km/h

  // Get vaccine counts from Delivery Information
  const vaccineInfoText = document.querySelector('.info-box').innerText.match(/Vaccine\s*:\s*([\s\S]*?)Latitude:/);
  let vaccines = [];
  if (vaccineInfoText && vaccineInfoText[1]) {
    // Example: "Covaxin: 3, Covishield: 4"
    const entries = vaccineInfoText[1].split(',').map(e => e.trim()).filter(e => e);
    entries.forEach(entry => {
      const parts = entry.split(':');
      if (parts.length === 2) {
        const name = parts[0].trim();
        const count = parseInt(parts[1].trim());
        for (let i = 0; i < count; i++) {
          vaccines.push(name);
        }
      }
    });
  }
  if (vaccines.length === 0) vaccines = ['VaccineA']; // fallback

  function animateDroneAlongPath(path, durationMs, marker, callback, etaCallback) {
    let segment = 0;
    let startTime = null;
    function step(ts) {
      if (!startTime) startTime = ts;
      const elapsed = ts - startTime;
      const totalProgress = Math.min(elapsed / durationMs, 1);
      const totalSegments = path.length - 1;
      const segProgress = totalProgress * totalSegments;
      segment = Math.floor(segProgress);
      const localT = segProgress - segment;
      if (segment >= totalSegments) {
        marker.setLatLng(path[path.length - 1]);
        if (etaCallback) etaCallback(0);
        if (callback) callback();
        return;
      }
      const [p1, p2] = [path[segment], path[segment + 1]];
      const lat = p1[0] + (p2[0] - p1[0]) * localT;
      const lng = p1[1] + (p2[1] - p1[1]) * localT;
      marker.setLatLng([lat, lng]);
      if (etaCallback) {
        const remainingMs = durationMs - elapsed;
        etaCallback(Math.max(0, Math.ceil(remainingMs / 1000)));
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // ------------------ Independent Drone Simulation ------------------
  // Batch token verification for all arrived drones
  const arrivedDrones = [];
  let tokenFormShown = false;
  function afterArrivalParallel(droneIdx, marker) {
    arrivedDrones.push({ idx: droneIdx, marker });
    // Only show one token form for all arrived drones
    if (!tokenFormShown) {
      tokenFormShown = true;
      const anchor = document.getElementById("batch-token-anchor");
      const formDiv = document.createElement("div");
      formDiv.id = "batch-token-form";
      formDiv.innerHTML = `
        <form id="tokenFormBatch">
          <label><strong>Enter Delivery Token to dispatch all arrived drones:</strong></label>
          <input type="text" id="deliveryTokenBatch" required>
          <button type="submit">Verify</button>
        </form>
        <div id="tokenErrorBatch" style="color:red;margin-top:8px;"></div>
      `;
      anchor.appendChild(formDiv);

      document.getElementById("tokenFormBatch").onsubmit = e => {
        e.preventDefault();
        const entered = document.getElementById("deliveryTokenBatch").value.trim();
        if (entered === serverToken) {
          // Dispatch all arrived drones
          arrivedDrones.forEach(({ idx, marker }) => {
            document.getElementById(`drone-status-msg-${idx}`).innerText = `Landing... Dispatching ${vaccines[idx]}...`;
            setTimeout(() => {
              document.getElementById(`drone-status-msg-${idx}`).innerText = `Returning to Home Station...`;
              animateDroneAlongPath([...path].reverse(), durationMs, marker, () => {
                document.getElementById(`drone-status-msg-${idx}`).innerText = `Delivered!`;
              }, (etaSec) => {
                const min = Math.floor(etaSec / 60);
                const sec = etaSec % 60;
                document.getElementById(`drone-eta-${idx}`).innerText = `ETA: ${min}m ${sec}s`;
              });
            }, 2000);
          });
          arrivedDrones.length = 0;
          tokenFormShown = false;
          formDiv.remove();
        } else {
          document.getElementById("tokenErrorBatch").innerText = "Invalid token! All arrived drones retreating.";
          arrivedDrones.forEach(({ idx, marker }) => {
            animateDroneAlongPath([...path].reverse(), durationMs, marker, () => {
              document.getElementById(`drone-status-msg-${idx}`).innerText = `Delivery Failed: Invalid Token`;
            }, (etaSec) => {
              const min = Math.floor(etaSec / 60);
              const sec = etaSec % 60;
              document.getElementById(`drone-eta-${idx}`).innerText = `ETA: ${min}m ${sec}s`;
            });
          });
          arrivedDrones.length = 0;
          tokenFormShown = false;
          setTimeout(() => formDiv.remove(), 2000);
        }
      };
    }
  }

  function startParallelDrones() {
    const statusList = document.getElementById("drone-status-list");
    statusList.innerHTML = "";
    vaccines.forEach((vaccine, i) => {
      const statusDiv = document.createElement("div");
      statusDiv.id = `drone-status-${i}`;
      statusDiv.className = "drone-status-box";
      statusDiv.innerHTML = `<strong>Drone ${i + 1} (${vaccine})</strong><div class="drone-eta" id="drone-eta-${i}">ETA: --</div><div class="drone-status-msg" id="drone-status-msg-${i}">Waiting for dispatch...</div>`;
      statusList.appendChild(statusDiv);
      setTimeout(() => {
        document.getElementById(`drone-status-msg-${i}`).innerText = `Heading to Target...`;
        const marker = L.marker([homeLat, homeLng], { icon: droneIcon }).addTo(map);
        marker.bindPopup(`Drone ${i + 1} - ${vaccine}`).openPopup();
        animateDroneAlongPath(
          path,
          durationMs,
          marker,
          () => { afterArrivalParallel(i, marker); },
          (etaSec) => {
            const min = Math.floor(etaSec / 60);
            const sec = etaSec % 60;
            document.getElementById(`drone-eta-${i}`).innerText = `ETA: ${min}m ${sec}s`;
          }
        );
      }, i * 4320);
    });
  }

  setTimeout(startParallelDrones, 2000); // Initial delay before first drone



</script>

</html>