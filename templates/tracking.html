<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drone Dispatch System</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f6f8fa;
      margin: 0;
      padding: 0;
    }

    header {
      background: #2d3748;
      color: #fff;
      padding: 1.5rem 0;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .hero {
      max-width: 1200px;
      margin: 2rem auto 0;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.07);
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      padding: 1rem;
      flex-direction: column;
    }

    #map {
      width: 100%;
      height: 400px;
      border-radius: 16px;
    }

    #eta {
      margin-top: 1rem;
      font-size: 1.2rem;
      color: #2563eb;
      font-weight: bold;
    }

    .container {
      max-width: 1200px;
      margin: 2rem auto;
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      padding: 0 1rem;
    }

    .info-box {
      flex: 1 1 350px;
      background: #fff;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.07);
      min-width: 280px;
    }

    h2 {
      color: #2563eb;
    }

    h3 {
      color: #16a34a;
    }
  </style>
</head>

<body>
  <header>
    <h1>Drone Dispatch System</h1>
  </header>
  <section class="hero">
    <div id="map"></div>
    <div id="eta">Calculating ETA...</div>
  </section>
  <main class="container">
    <section class="info-box">
      <h2>Delivery Information</h2>
      <ul>
        <li><strong>Vaccine Type:</strong> {{ data.vaccine_type if data else '---' }}<br>
          <strong>Latitude:</strong> {{ data.latitude if data else '---' }}<br>
          <strong>Longitude:</strong> {{ data.longitude if data else '---' }}<br>
          <strong>Distance:</strong> {{ data.distance if data else '---' }} km<br>
          <strong>Access Token:</strong> <span id="serverToken">{{ token if token else '' }}</span>
        </li>
      </ul>
    </section>

  </main>
</body>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  // ------------------ Setup ------------------
  const homeLat = 30.3529, homeLng = 76.3637;
  const targetLat = {{ data.latitude|default (30.3529) }},
  targetLng = {{ data.longitude |default (76.3637) }};

  const serverToken = document.getElementById("serverToken").innerText.trim() ||
    Math.floor(100000 + Math.random() * 900000).toString(); // fallback token

  const map = L.map('map').setView([homeLat, homeLng], 14);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

  L.marker([homeLat, homeLng]).addTo(map).bindPopup("Home Station").openPopup();
  L.marker([targetLat, targetLng]).addTo(map).bindPopup("Delivery Location");

  // ------------------ No Fly Zones ------------------
  // Define no-fly zones directly as circles: [centerLat, centerLng, radius]
  const noFlyZones = [
    [30.3565, 76.3615, 0.002], // Zone 1
    [30.3495, 76.3565, 0.002], // Zone 2
    [30.3465, 76.3665, 0.002], // Zone 3
    [30.3515, 76.3715, 0.002], // Zone 4
    [30.34325, 76.36125, 0.0015] // Zone 5
  ];

  // Render zones as circles
  noFlyZones.forEach(([lat, lng, r]) => {
    L.circle([lat, lng], {
      radius: r * 111000, // convert approx degrees → meters
      color: "red",
      fillColor: "red",
      fillOpacity: 0.5
    }).addTo(map);
  });


  // ------------------ Check if destination is inside a no-fly zone ------------------
  function isPointInsideNoFlyZones(point, zones) {
    const [lat, lng] = point;
    for (const [cLat, cLng, radius] of zones) {
      const dLat = lat - cLat;
      const dLng = lng - cLng;
      const dist = Math.sqrt(dLat * dLat + dLng * dLng);
      if (dist <= radius) {
        return true; // inside zone
      }
    }
    return false;
  }

  // ------------------ Path Calculation ------------------
  function computeSafePath(start, end, zones) {
    const path = [start];
    let current = start;
    // helper: check if line intersects circle
    function lineIntersectsCircle(p1, p2, center, r) {
      const [x1, y1] = [p1[1], p1[0]];
      const [x2, y2] = [p2[1], p2[0]];
      const [cx, cy] = [center[1], center[0]];

      const dx = x2 - x1, dy = y2 - y1;
      const fx = x1 - cx, fy = y1 - cy;

      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = (fx * fx + fy * fy) - r * r;

      let disc = b * b - 4 * a * c;
      if (disc < 0) return false;
      disc = Math.sqrt(disc);
      const t1 = (-b - disc) / (2 * a);
      const t2 = (-b + disc) / (2 * a);

      return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
    }

    while (true) {
      let detourAdded = false;

      for (const zone of zones) {
        const [cLat, cLng, radius] = zone;

        // if current→end intersects this zone
        if (lineIntersectsCircle(current, end, [cLat, cLng], radius)) {
          const [sLat, sLng] = current;

          // base angle from current → circle center
          const baseAngle = Math.atan2(cLat - sLat, cLng - sLng);

          // try two tangent detours
          const tangentCandidates = [];
          [Math.PI / 2, -Math.PI / 2].forEach(offset => {
            const angle = baseAngle + offset;
            tangentCandidates.push([
              cLat + (radius + 0.0005) * Math.sin(angle), // <-- added margin
              cLng + (radius + 0.0005) * Math.cos(angle)  // <-- added margin
            ]);
          });


          // pick first safe tangent candidate
          let safeDetour = null;
          for (const cand of tangentCandidates) {
            let safe = true;
            for (const z of zones) {
              const [czLat, czLng, r] = z;
              if (lineIntersectsCircle(cand, end, [czLat, czLng], r)) {
                safe = false;
                break;
              }
            }
            if (safe) {
              safeDetour = cand;
              break;
            }
          }

          // fallback if none safe: expand outward from circle
          if (!safeDetour) {
            let cand = tangentCandidates[0];
            let tries = 0;
            while (tries < 50) {
              cand = [
                cLat + (radius + 0.0005 * (tries + 1)) * Math.sin(baseAngle + Math.PI / 2),
                cLng + (radius + 0.0005 * (tries + 1)) * Math.cos(baseAngle + Math.PI / 2)
              ];
              // check if cand→end is safe...
              let ok = true;
              for (const z of zones) {
                const [czLat, czLng, r] = z;
                if (lineIntersectsCircle(cand, end, [czLat, czLng], r)) {
                  ok = false;
                  break;
                }
              }
              if (ok) { safeDetour = cand; break; }
              tries++;
            }
          }


          path.push(safeDetour);
          current = safeDetour;
          detourAdded = true;
          break; // re-check from new current
        }
      }

      if (!detourAdded) {
        path.push(end);
        break;
      }
    }

    return path;
  }


  // ------------------ Draw Path ------------------
  let path = [];  // declare globally

  if (isPointInsideNoFlyZones([targetLat, targetLng], noFlyZones)) {
    alert("❌ Cannot deliver: Destination lies inside a no-fly zone!");
  } else {
    path = computeSafePath([homeLat, homeLng], [targetLat, targetLng], noFlyZones);
    L.polyline(path, { color: 'blue', weight: 4 }).addTo(map);
  }



  // ------------------ Animation Helpers ------------------
  const droneIcon = L.icon({ iconUrl: "static/icons/drone.ico", iconSize: [40, 40], iconAnchor: [20, 20] });
  const droneMarker = L.marker([homeLat, homeLng], { icon: droneIcon }).addTo(map);

  const distanceMeters = map.distance([homeLat, homeLng], [targetLat, targetLng]);
  const durationMs = (distanceMeters / 1000 / 100) * 3600 * 1000; // speed=100 km/h

  function animateDroneAlongPath(path, durationMs, callback) {
    let segment = 0;
    let startTime = null;

    function step(ts) {
      if (!startTime) startTime = ts;
      const totalProgress = Math.min((ts - startTime) / durationMs, 1);
      const totalSegments = path.length - 1;
      const segProgress = totalProgress * totalSegments;
      segment = Math.floor(segProgress);
      const localT = segProgress - segment;

      if (segment >= totalSegments) {
        droneMarker.setLatLng(path[path.length - 1]);
        if (callback) callback();
        return;
      }

      const [p1, p2] = [path[segment], path[segment + 1]];
      const lat = p1[0] + (p2[0] - p1[0]) * localT;
      const lng = p1[1] + (p2[1] - p1[1]) * localT;
      droneMarker.setLatLng([lat, lng]);

      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // ------------------ Token & Return Logic ------------------
  function afterArrival() {
    const etaDiv = document.getElementById("eta");
    etaDiv.innerHTML = `
      <form id="tokenForm">
        <label><strong>Enter Delivery Token:</strong></label>
        <input type="text" id="deliveryToken" required>
        <button type="submit">Verify</button>
      </form>
      <div id="tokenError" style="color:red;margin-top:8px;"></div>
    `;

    document.getElementById("tokenForm").onsubmit = e => {
      e.preventDefault();
      const entered = document.getElementById("deliveryToken").value.trim();
      if (entered === serverToken) {
        etaDiv.innerText = "Landing... Dispatching vaccine...";
        setTimeout(() => {
          etaDiv.innerText = "Returning to Home Station...";
          animateDroneAlongPath([...path].reverse(), durationMs, () => {
            etaDiv.innerText = "Delivered!";
          });
        }, 2000);
      } else {
        document.getElementById("tokenError").innerText = "Invalid token! Drone retreating.";
        animateDroneAlongPath([...path].reverse(), durationMs, () => {
          etaDiv.innerText = "Delivery Failed: Invalid Token";
        });
      }
    };
  }

  // ------------------ Sequence ------------------
  function startSequence() {
    document.getElementById("eta").innerText = "Drone Assigned...";
    setTimeout(() => {
      document.getElementById("eta").innerText = "Heading to Target...";
      animateDroneAlongPath(path, durationMs, afterArrival);
    }, 2000);
  }

  startSequence();
</script>

</html>