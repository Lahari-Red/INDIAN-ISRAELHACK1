<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drone Dispatch System</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f6f8fa;
      margin: 0;
      padding: 0;
    }

    header {
      background: #2d3748;
      color: #fff;
      padding: 1.5rem 0;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .hero {
      max-width: 1200px;
      margin: 2rem auto 0;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.07);
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      padding: 1rem;
      flex-direction: column;
    }

    #map {
      width: 100%;
      height: 400px;
      border-radius: 16px;
    }

    #eta {
      margin-top: 1rem;
      font-size: 1.2rem;
      color: #2563eb;
      font-weight: bold;
    }

    .container {
      max-width: 1200px;
      margin: 2rem auto;
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      padding: 0 1rem;
    }

    .info-box {
      flex: 1 1 350px;
      background: #fff;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.07);
      min-width: 280px;
    }

    h2 {
      color: #2563eb;
    }

    h3 {
      color: #16a34a;
    }
  </style>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>

<body>
  <header>
    <h1>Drone Dispatch System</h1>
  </header>
  <section class="hero">
    <div id="map"></div>
    <div id="eta">Calculating ETA...</div>
    <div id="drone-status-list"></div>
  </section>
  <main class="container">
    <section class="info-box">
      <h2>Delivery Information</h2>
      <strong>Vaccine Type:</strong> {{ ','.join(data.vaccine_types) if data and data.vaccine_types else '---'
      }}<br>
      <strong>Latitude:</strong> {{ data.latitude if data else '---' }}<br>
      <strong>Longitude:</strong> {{ data.longitude if data else '---' }}<br>
      <strong>Distance:</strong> {{ data.distance if data else '---' }} km<br>
      <strong>Access Token:</strong> <span id="serverToken">{{ token if token else '' }}</span>
    </section>

  </main>
</body>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  // ------------------ Setup ------------------
  const homeLat = 30.3529, homeLng = 76.3637;
  const targetLat = parseFloat("{{ data.latitude|default(30.3529) }}");
  const targetLng = parseFloat("{{ data.longitude|default(76.3637) }}");

  const serverToken = document.getElementById("serverToken").innerText.trim() ||
    Math.floor(100000 + Math.random() * 900000).toString(); // fallback token

  const map = L.map('map').setView([homeLat, homeLng], 14);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

  L.marker([homeLat, homeLng]).addTo(map).bindPopup("Home Station").openPopup();
  L.marker([targetLat, targetLng]).addTo(map).bindPopup("Delivery Location");

  // ------------------ No Fly Zones ------------------
  // Define no-fly zones directly as circles: [centerLat, centerLng, radius]
  const noFlyZones = [
    [30.3565, 76.3615, 0.002], // Zone 1
    [30.3495, 76.3565, 0.002], // Zone 2
    [30.3465, 76.3665, 0.002], // Zone 3
    [30.3515, 76.3715, 0.002], // Zone 4
    [30.34325, 76.36125, 0.0015] // Zone 5
  ];

  // Render zones as circles
  noFlyZones.forEach(([lat, lng, r]) => {
    L.circle([lat, lng], {
      radius: r * 111000, // convert approx degrees → meters
      color: "red",
      fillColor: "red",
      fillOpacity: 0.5
    }).addTo(map);
  });


  // ------------------ Check if destination is inside a no-fly zone ------------------
  function isPointInsideNoFlyZones(point, zones) {
    const [lat, lng] = point;
    for (const [cLat, cLng, radius] of zones) {
      const dLat = lat - cLat;
      const dLng = lng - cLng;
      const dist = Math.sqrt(dLat * dLat + dLng * dLng);
      if (dist <= radius) {
        return true; // inside zone
      }
    }
    return false;
  }

  // ------------------ Path Calculation ------------------
  function computeSafePath(start, end, zones) {
    const path = [start];
    let current = start;
    // helper: check if line intersects circle
    function lineIntersectsCircle(p1, p2, center, r) {
      const [x1, y1] = [p1[1], p1[0]];
      const [x2, y2] = [p2[1], p2[0]];
      const [cx, cy] = [center[1], center[0]];

      const dx = x2 - x1, dy = y2 - y1;
      const fx = x1 - cx, fy = y1 - cy;

      const a = dx * dx + dy * dy;
      const b = 2 * (fx * dx + fy * dy);
      const c = (fx * fx + fy * fy) - r * r;

      let disc = b * b - 4 * a * c;
      if (disc < 0) return false;
      disc = Math.sqrt(disc);
      const t1 = (-b - disc) / (2 * a);
      const t2 = (-b + disc) / (2 * a);

      return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
    }

    while (true) {
      let detourAdded = false;

      for (const zone of zones) {
        const [cLat, cLng, radius] = zone;

        // if current→end intersects this zone
        if (lineIntersectsCircle(current, end, [cLat, cLng], radius)) {
          const [sLat, sLng] = current;

          // base angle from current → circle center
          const baseAngle = Math.atan2(cLat - sLat, cLng - sLng);

          // try two tangent detours
          const tangentCandidates = [];
          [Math.PI / 2, -Math.PI / 2].forEach(offset => {
            const angle = baseAngle + offset;
            tangentCandidates.push([
              cLat + (radius + 0.0005) * Math.sin(angle), // <-- added margin
              cLng + (radius + 0.0005) * Math.cos(angle)  // <-- added margin
            ]);
          });


          // pick first safe tangent candidate
          let safeDetour = null;
          for (const cand of tangentCandidates) {
            let safe = true;
            for (const z of zones) {
              const [czLat, czLng, r] = z;
              if (lineIntersectsCircle(cand, end, [czLat, czLng], r)) {
                safe = false;
                break;
              }
            }
            if (safe) {
              safeDetour = cand;
              break;
            }
          }

          // fallback if none safe: expand outward from circle
          if (!safeDetour) {
            let cand = tangentCandidates[0];
            let tries = 0;
            while (tries < 50) {
              cand = [
                cLat + (radius + 0.0005 * (tries + 1)) * Math.sin(baseAngle + Math.PI / 2),
                cLng + (radius + 0.0005 * (tries + 1)) * Math.cos(baseAngle + Math.PI / 2)
              ];
              // check if cand→end is safe...
              let ok = true;
              for (const z of zones) {
                const [czLat, czLng, r] = z;
                if (lineIntersectsCircle(cand, end, [czLat, czLng], r)) {
                  ok = false;
                  break;
                }
              }
              if (ok) { safeDetour = cand; break; }
              tries++;
            }
          }


          path.push(safeDetour);
          current = safeDetour;
          detourAdded = true;
          break; // re-check from new current
        }
      }

      if (!detourAdded) {
        path.push(end);
        break;
      }
    }

    return path;
  }


  // ------------------ Draw Path ------------------
  let path = [];  // declare globally

  if (isPointInsideNoFlyZones([targetLat, targetLng], noFlyZones)) {
    alert("❌ Cannot deliver: Destination lies inside a no-fly zone!");
  } else {
    path = computeSafePath([homeLat, homeLng], [targetLat, targetLng], noFlyZones);
    L.polyline(path, { color: 'blue', weight: 4 }).addTo(map);
  }




  // ------------------ Animation Helpers (Multiple Drones) ------------------
  const droneIcon = L.icon({ iconUrl: "static/icons/drone.ico", iconSize: [40, 40], iconAnchor: [20, 20] });
  const distanceMeters = map.distance([homeLat, homeLng], [targetLat, targetLng]);
  const durationMs = (distanceMeters / 1000 / 100) * 3600 * 1000; // speed=100 km/h

  // Get vaccine types from backend data (already rendered in Delivery Information)
  const vaccineTypesText = document.querySelector('.info-box').innerText.match(/Vaccine Type:\s*(.*)/);
  let vaccines = [];
  if (vaccineTypesText && vaccineTypesText[1]) {
    vaccines = vaccineTypesText[1].split(',').map(v => v.trim()).filter(v => v);
  }
  if (vaccines.length === 0) vaccines = ['VaccineA']; // fallback

  function animateDroneAlongPath(path, durationMs, marker, callback) {
    let segment = 0;
    let startTime = null;
    function step(ts) {
      if (!startTime) startTime = ts;
      const totalProgress = Math.min((ts - startTime) / durationMs, 1);
      const totalSegments = path.length - 1;
      const segProgress = totalProgress * totalSegments;
      segment = Math.floor(segProgress);
      const localT = segProgress - segment;
      if (segment >= totalSegments) {
        marker.setLatLng(path[path.length - 1]);
        if (callback) callback();
        return;
      }
      const [p1, p2] = [path[segment], path[segment + 1]];
      const lat = p1[0] + (p2[0] - p1[0]) * localT;
      const lng = p1[1] + (p2[1] - p1[1]) * localT;
      marker.setLatLng([lat, lng]);
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  // ------------------ Independent Drone Simulation ------------------
  function afterArrivalParallel(droneIdx, marker) {
    const statusDiv = document.getElementById(`drone-status-${droneIdx}`);
    statusDiv.innerHTML = `
      <form id="tokenForm${droneIdx}">
        <label><strong>Drone ${droneIdx + 1} (${vaccines[droneIdx]}): Enter Delivery Token:</strong></label>
        <input type="text" id="deliveryToken${droneIdx}" required>
        <button type="submit">Verify</button>
      </form>
      <div id="tokenError${droneIdx}" style="color:red;margin-top:8px;"></div>
    `;

    document.getElementById(`tokenForm${droneIdx}`).onsubmit = e => {
      e.preventDefault();
      const entered = document.getElementById(`deliveryToken${droneIdx}`).value.trim();
      if (entered === serverToken) {
        statusDiv.innerText = `Drone ${droneIdx + 1} Landing... Dispatching ${vaccines[droneIdx]}...`;
        setTimeout(() => {
          statusDiv.innerText = `Drone ${droneIdx + 1} Returning to Home Station...`;
          animateDroneAlongPath([...path].reverse(), durationMs, marker, () => {
            statusDiv.innerText = `Drone ${droneIdx + 1} Delivered!`;
          });
        }, 2000);
      } else {
        document.getElementById(`tokenError${droneIdx}`).innerText = "Invalid token! Drone retreating.";
        animateDroneAlongPath([...path].reverse(), durationMs, marker, () => {
          statusDiv.innerText = `Drone ${droneIdx + 1} Delivery Failed: Invalid Token`;
        });
      }
    };
  }

  function startParallelDrones() {
    const statusList = document.getElementById("drone-status-list");
    statusList.innerHTML = "";
    vaccines.forEach((vaccine, i) => {
      const statusDiv = document.createElement("div");
      statusDiv.id = `drone-status-${i}`;
      statusDiv.style.marginBottom = "1em";
      statusDiv.innerText = `Drone ${i + 1} (${vaccine}) waiting for dispatch...`;
      statusList.appendChild(statusDiv);
      setTimeout(() => {
        statusDiv.innerText = `Drone ${i + 1} (${vaccine}) heading to Target...`;
        const marker = L.marker([homeLat, homeLng], { icon: droneIcon }).addTo(map);
        marker.bindPopup(`Drone ${i + 1} - ${vaccine}`).openPopup();
        animateDroneAlongPath(path, durationMs, marker, () => {
          afterArrivalParallel(i, marker);
        });
      }, i * 13000);
    });
  }

  setTimeout(startParallelDrones, 2000); // Initial delay before first drone



</script>

</html>